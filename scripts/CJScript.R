rm(list=ls())

library(MASS)  #stepAIC, 
library(dfexplore) #dfplot
library(caret)  #traincontrol
library(readxl)  #read_excel
library(dfexplore) #dfplot
library(questionr)
library(psych)
library(ggplot2)
library(corrplot)
library(car)
library(caret)
library(Amelia)
library(dplyr) #glimpse
library(rpart) 
library(rpart.plot)
library(randomForest)

source("FuncionesParaDataUnderstandingAndPreparation.R")
source("steprepetidobinaria.R")
source("cruzadalogisticaavnet.R")
source("cruzadarfbinaria.R")
source("cruzadagbmbinaria.R")
source("cruzadxgboost.R")
source("cruzadaSVMbinlineal.R")
source("cruzadaSVMbinPoly.R")
source("cruzadasensambladobin.R")
source("cruzadaarbolbin.R")

datafile<-readRDS("datapiece1")
#validacion tipos de datos
str(datafile)
glimpse(datafile)  #se usar str, dado que da idea de cuantos levels se tienen

summary(datafile)

# Retipado ----------------------------------------------------------------
##se va a revisar los datos para validar que esta correctamente categorizados
datafile$MachineIdentifier <-toString(datafile$MachineIdentifier) #es del tipo string, no entrara en el analisis
datafile$EngineVersion <- toString(datafile$EngineVersion)
datafile$AppVersion <- toString(datafile$AppVersion)
datafile$AvSigVersion <- toString(datafile$AvSigVersion)
datafile$IsBeta <- factor(datafile$IsBeta)
datafile$RtpStateBitfield <- factor(datafile$RtpStateBitfield)
datafile$IsSxsPassiveMode <- factor(datafile$IsSxsPassiveMode)
datafile$AVProductsInstalled <- factor(datafile$AVProductsInstalled)
datafile$AVProductsEnabled <- factor(datafile$AVProductsEnabled)
datafile$HasTpm <- factor(datafile$HasTpm)
datafile$OsVer <- toString(datafile$OsVer)
datafile$OsBuildLab <- toString(datafile$OsBuildLab)
datafile$IsProtected <- factor(datafile$IsProtected)
datafile$AutoSampleOptIn <- factor(datafile$AutoSampleOptIn)
datafile$SMode <- factor(datafile$SMode)
datafile$SmartScreen <- toString(datafile$SmartScreen)
datafile$Firewall <- factor(datafile$Firewall)
datafile$UacLuaenable <-factor(datafile$UacLuaenable)
datafile$Census_MDC2FormFactor <- toString(datafile$Census_MDC2FormFactor)
datafile$Census_HasOpticalDiskDrive <- factor(datafile$Census_HasOpticalDiskDrive)
datafile$Census_ChassisTypeName <- toString(datafile$Census_ChassisTypeName)
datafile$Census_PowerPlatformRoleName <- toString(datafile$Census_PowerPlatformRoleName)
datafile$Census_InternalBatteryType <- toString(datafile$Census_InternalBatteryType)
datafile$Census_OSVersion <- toString(datafile$Census_OSVersion)
datafile$Census_OSArchitecture <- factor(datafile$Census_OSArchitecture)
datafile$Census_OSBranch <- toString(datafile$Census_OSBranch)
datafile$Census_OSEdition <- toString(datafile$Census_OSEdition)
datafile$Census_OSSkuName <- toString(datafile$Census_OSSkuName)
datafile$Census_IsPortableOperatingSystem <- factor(datafile$Census_IsPortableOperatingSystem)
datafile$Census_GenuineStateName <- factor(datafile$Census_GenuineStateName)
datafile$Census_IsFlightingInternal <- factor(datafile$Census_IsFlightingInternal)
datafile$Census_IsFlightsDisabled <- factor(datafile$Census_IsFlightsDisabled)
datafile$Census_ThresholdOptIn <- factor(datafile$Census_ThresholdOptIn)
datafile$Census_IsSecureBootEnabled <- factor(datafile$Census_IsSecureBootEnabled)
datafile$Census_IsWIMBootEnabled <- factor(datafile$Census_IsWIMBootEnabled)
datafile$Census_IsVirtualDevice <- factor(datafile$Census_IsVirtualDevice)
datafile$Census_IsTouchEnabled <- factor(datafile$Census_IsTouchEnabled)
datafile$Census_IsPenCapable <- factor(datafile$Census_IsPenCapable)
datafile$Census_IsAlwaysOnAlwaysConnectedCapable <- factor(datafile$Census_IsAlwaysOnAlwaysConnectedCapable)
datafile$Wdft_IsGamer <- factor(datafile$Wdft_IsGamer)
datafile$HasDetections <- factor(datafile$HasDetections)


# DeclaracionVariables ----------------------------------------------------------------
dput(names(datafile))
listclass <- c("ProductName","IsBeta", "RtpStateBitfield", "IsSxsPassiveMode","AVProductsInstalled", 
             "AVProductsEnabled", "HasTpm","Platform", "Processor", "OsPlatformSubRelease",
             "SkuEdition", "IsProtected", "AutoSampleOptIn","PuaMode","SMode", "Firewall", "UacLuaenable", 
             "Census_DeviceFamily","Census_ProcessorClass", "Census_PrimaryDiskTypeName", 
             "Census_HasOpticalDiskDrive","Census_OSArchitecture", "Census_OSInstallTypeName",
             "Census_OSWUAutoUpdateOptionsName","Census_IsPortableOperatingSystem", 
             "Census_GenuineStateName","Census_ActivationChannel", "Census_IsFlightingInternal", 
             "Census_IsFlightsDisabled","Census_FlightRing", "Census_ThresholdOptIn", "Census_IsSecureBootEnabled", 
             "Census_IsWIMBootEnabled", "Census_IsVirtualDevice", "Census_IsTouchEnabled", 
             "Census_IsPenCapable", "Census_IsAlwaysOnAlwaysConnectedCapable", "Wdft_IsGamer")

listconti <- c("AVProductStatesIdentifier","CountryIdentifier", "CityIdentifier", "OrganizationIdentifier",
               "GeoNameIdentifier", "LocaleEnglishNameIdentifier", "OsBuild", "OsSuite","IeVerIdentifier",
               "Census_OEMNameIdentifier", "Census_OEMModelIdentifier", "Census_ProcessorCoreCount",
               "Census_ProcessorManufacturerIdentifier", "Census_ProcessorModelIdentifier",
               "Census_PrimaryDiskTotalCapacity","Census_SystemVolumeTotalCapacity","Census_TotalPhysicalRAM", 
               "Census_InternalPrimaryDiagonalDisplaySizeInInches", "Census_InternalPrimaryDisplayResolutionHorizontal",
               "Census_InternalPrimaryDisplayResolutionVertical", "Census_InternalBatteryNumberOfCharges",  
               "Census_OSBuildNumber","Census_OSBuildRevision",  "Census_OSInstallLanguageIdentifier", 
               "Census_OSUILocaleIdentifier","Census_FirmwareManufacturerIdentifier", "Census_FirmwareVersionIdentifier",
               "Wdft_RegionIdentifier")
varChar <- c("MachineIdentifier", "EngineVersion", "AppVersion", 
             "AvSigVersion","OsVer","OsBuildLab","SmartScreen", "Census_MDC2FormFactor",  
             "Census_ChassisTypeName",  
             "Census_PowerPlatformRoleName", "Census_InternalBatteryType", 
             "Census_OSVersion", 
             "Census_OSBranch", "Census_OSEdition", "Census_OSSkuName")
vardep<- c("HasDetections")


# AnalisisDatos-Missings ----------------------------------------------------------------

matriznulos<-matrizdenulos(datafile)

nrows <- nrow(datafile)
ncomplete <- sum(complete.cases(datafile))
result <- ncomplete/nrows  
result #porcentaje de filas completas, se observa que elos el 0.0025 esta completo por lo que se tendra que analizar cada valor nulo.

  #graficas para apoyar visualizacion de datos nulos
  # - Análisis de la coexistencia de datos faltantes en varias variables
  corrplot(cor(is.na(datafile[colnames(datafile)[colSums(
    is.na(datafile))>0]])),method = "ellipse",type = "upper")
  
  dfplot(datafile)  #grafica para ver data y q nulos
  missmap(datafile, main = "Missing values vs observed")
#antes de realizar correcciones sobre los missings como eliminar o imputar, se va a analizar otros tipos de errores, para hacer una correcta imputacion

# AnalisisDatos-DatoaAsimetricos-----------------------------------------------------

tablasimetria<- psych::describe(Filter(is.numeric, datafile)) #Análisis de la simetría de las variables y de la posible existencia de datos atípicos

# AnalisisDatos-DatoaAsimetricosgraficos----------------------------------------------
#revisar de acuerdo a los resultados de la tablas de asimetria si se encuentra algun atipico
#se apoyara con el grafico siguiente
#Plotting the dependent variable distribution
pl1 <- ggplot(datafile, aes(datafile$DefaultBrowsersIdentifier)) #parece normal, mucho nulo
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$DefaultBrowsersIdentifier)
boxplot.stats(datafile$DefaultBrowsersIdentifier)$out

pl1 <- ggplot(datafile, aes(datafile$AVProductStatesIdentifier)) #podrian existir atipicos
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$AVProductStatesIdentifier)
outlinersprodstates<-order(boxplot.stats(datafile$AVProductStatesIdentifier)$out)
sort(outlinersprodstates)
fivenum(datafile$AVProductStatesIdentifier)

pl1 <- ggplot(datafile, aes(datafile$CountryIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$CountryIdentifier)
boxplot.stats(datafile$CountryIdentifier)$out #no retorna nada

pl1 <- ggplot(datafile, aes(datafile$CityIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$CityIdentifier)
boxplot.stats(datafile$CityIdentifier)$out #no retorna nada

pl1 <- ggplot(datafile, aes(datafile$OrganizationIdentifier)) # podrian existir atipicos
pl1 + geom_density(fill = "red", alpha = "0.7")
outlinerorganization<-boxplot(datafile$OrganizationIdentifier)
boxplot.stats(datafile$OrganizationIdentifier)$out

pl1 <- ggplot(datafile, aes(datafile$GeoNameIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$GeoNameIdentifier)
boxplot.stats(datafile$GeoNameIdentifier)$out
hboutlier(datafile$GeoNameIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$LocaleEnglishNameIdentifier)) # parece normal ??
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$LocaleEnglishNameIdentifier)
boxplot.stats(datafile$LocaleEnglishNameIdentifier)$out

pl1 <- ggplot(datafile, aes(datafile$OsBuild)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$OsBuild)
boxplot.stats(datafile$OsBuild)$out

pl1 <- ggplot(datafile, aes(datafile$OsSuite)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$OsSuite)
boxplot.stats(datafile$OsSuite)$out

pl1 <- ggplot(datafile, aes(datafile$IeVerIdentifier)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$IeVerIdentifier)
boxplot.stats(datafile$IeVerIdentifier)$out
hboutlier(datafile$IeVerIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_OEMNameIdentifier)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_OEMNameIdentifier)
boxplot.stats(datafile$Census_OEMNameIdentifier)$out
hboutlier(datafile$Census_OEMNameIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_ProcessorModelIdentifier)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_ProcessorModelIdentifier)
boxplot.stats(datafile$Census_ProcessorModelIdentifier)$out
hboutlier(datafile$Census_ProcessorModelIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_PrimaryDiskTotalCapacity)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_PrimaryDiskTotalCapacity)
boxplot.stats(datafile$Census_PrimaryDiskTotalCapacity)$out
hboutlier(datafile$Census_PrimaryDiskTotalCapacity,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_SystemVolumeTotalCapacity)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_SystemVolumeTotalCapacity)
boxplot.stats(datafile$Census_SystemVolumeTotalCapacity)$out
hboutlier(datafile$Census_SystemVolumeTotalCapacity,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_TotalPhysicalRAM)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_TotalPhysicalRAM)
boxplot.stats(datafile$Census_TotalPhysicalRAM)$out
hboutlier(datafile$Census_TotalPhysicalRAM,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_InternalPrimaryDiagonalDisplaySizeInInches)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_InternalPrimaryDiagonalDisplaySizeInInches)
boxplot.stats(datafile$Census_InternalPrimaryDiagonalDisplaySizeInInches)$out
hboutlier(datafile$Census_InternalPrimaryDiagonalDisplaySizeInInches,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_InternalPrimaryDisplayResolutionHorizontal)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_InternalPrimaryDisplayResolutionHorizontal)
boxplot.stats(datafile$Census_InternalPrimaryDisplayResolutionHorizontal)$out
hboutlier(datafile$Census_InternalPrimaryDisplayResolutionHorizontal,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_InternalPrimaryDisplayResolutionVertical)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_InternalPrimaryDisplayResolutionVertical)
boxplot.stats(datafile$Census_InternalPrimaryDisplayResolutionVertical)$out
hboutlier(datafile$Census_InternalPrimaryDisplayResolutionVertical,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_InternalBatteryNumberOfCharges)) # parece normal ??? 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_InternalBatteryNumberOfCharges)
boxplot.stats(datafile$Census_InternalBatteryNumberOfCharges)$out
hboutlier(datafile$Census_InternalBatteryNumberOfCharges,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_OSBuildNumber)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_OSBuildNumber)
boxplot.stats(datafile$Census_OSBuildNumber)$out
hboutlier(datafile$Census_OSBuildNumber,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_OSBuildRevision)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_OSBuildRevision)
boxplot.stats(datafile$Census_OSBuildRevision)$out
hboutlier(datafile$Census_OSBuildRevision,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_OSInstallLanguageIdentifier)) # podrian existir atipicos 
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_OSInstallLanguageIdentifier)
boxplot.stats(datafile$Census_OSInstallLanguageIdentifier)$out
hboutlier(datafile$Census_OSInstallLanguageIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_OSUILocaleIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_OSUILocaleIdentifier)
boxplot.stats(datafile$Census_OSUILocaleIdentifier)$out
hboutlier(datafile$Census_OSUILocaleIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_FirmwareManufacturerIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_FirmwareManufacturerIdentifier)
boxplot.stats(datafile$Census_FirmwareManufacturerIdentifier)$out
hboutlier(datafile$Census_FirmwareManufacturerIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Census_FirmwareVersionIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Census_FirmwareVersionIdentifier)
boxplot.stats(datafile$Census_FirmwareVersionIdentifier)$out
hboutlier(datafile$Census_FirmwareVersionIdentifier,1.5)  #funcion adicional de ayuda, investigar

pl1 <- ggplot(datafile, aes(datafile$Wdft_RegionIdentifier)) # parece normal
pl1 + geom_density(fill = "red", alpha = "0.7")
boxplot(datafile$Wdft_RegionIdentifier)
boxplot.stats(datafile$Wdft_RegionIdentifier)$out
hboutlier(datafile$Wdft_RegionIdentifier,1.5)  #funcion adicional de ayuda, investigar
#se va a mantener los datos atipicos





# AnalisisDatos-Representacioncategoriasminoritarias-----------------------------------------------------
#Comprobación de la representatividad de las categorías minoritarias de las variables cualitativas.
questionr::freq(datafile$ProductName) 
questionr::freq(datafile$IsBeta)
questionr::freq(datafile$RtpStateBitfield)
questionr::freq(datafile$IsSxsPassiveMode)
questionr::freq(datafile$AVProductsInstalled)
questionr::freq(datafile$AVProductsEnabled)
questionr::freq(datafile$HasTpm)
questionr::freq(datafile$Platform)
questionr::freq(datafile$Processor)
questionr::freq(datafile$OsPlatformSubRelease)
questionr::freq(datafile$SkuEdition)
questionr::freq(datafile$IsProtected)
questionr::freq(datafile$AutoSampleOptIn)
questionr::freq(datafile$PuaMode)
questionr::freq(datafile$SMode)
questionr::freq(datafile$Firewall)
questionr::freq(datafile$UacLuaenable)
questionr::freq(datafile$Census_DeviceFamily)
questionr::freq(datafile$Census_ProcessorClass)
questionr::freq(datafile$Census_PrimaryDiskTypeName)
questionr::freq(datafile$Census_HasOpticalDiskDrive)
questionr::freq(datafile$Census_OSArchitecture)
questionr::freq(datafile$Census_OSInstallTypeName)
questionr::freq(datafile$Census_OSWUAutoUpdateOptionsName)
questionr::freq(datafile$Census_IsPortableOperatingSystem)
questionr::freq(datafile$Census_GenuineStateName)
questionr::freq(datafile$Census_IsPortableOperatingSystem)
questionr::freq(datafile$Census_ActivationChannel)
questionr::freq(datafile$Census_IsFlightingInternal)
questionr::freq(datafile$Census_IsFlightsDisabled)
questionr::freq(datafile$Census_FlightRing)
questionr::freq(datafile$Census_ThresholdOptIn)
questionr::freq(datafile$Census_IsSecureBootEnabled)
questionr::freq(datafile$Census_IsWIMBootEnabled)
questionr::freq(datafile$Census_IsVirtualDevice)
questionr::freq(datafile$Census_IsTouchEnabled)
questionr::freq(datafile$Census_IsPenCapable)
questionr::freq(datafile$Census_IsAlwaysOnAlwaysConnectedCapable)
questionr::freq(datafile$Wdft_IsGamer)


# DataPreparation-TratamientosNulos----------------------------------------------
#de lo analizado en los valores nulos, se va a eliminar las filas que tengan campos missings menores o iguales a 5, estos representan la minoria

matriznulos[order(matriznulos[,2]),]

datafile<-datafile[!is.na(datafile$RtpStateBitfield), ]
datafile<-datafile[!is.na(datafile$AVProductStatesIdentifier), ]
datafile<-datafile[!is.na(datafile$AVProductsInstalled), ]
datafile<-datafile[!is.na(datafile$AVProductsEnabled), ]
datafile<-datafile[!is.na(datafile$IsProtected), ]
datafile<-datafile[!is.na(datafile$UacLuaenable), ]
datafile<-datafile[!is.na(datafile$Census_InternalPrimaryDiagonalDisplaySizeInInches), ]
datafile<-datafile[!is.na(datafile$Census_InternalPrimaryDisplayResolutionHorizontal), ]
datafile<-datafile[!is.na(datafile$Census_InternalPrimaryDisplayResolutionVertical), ]
datafile<-datafile[!is.na(datafile$Census_ProcessorCoreCount), ]
datafile<-datafile[!is.na(datafile$Census_ProcessorManufacturerIdentifier), ]
datafile<-datafile[!is.na(datafile$Census_ProcessorModelIdentifier), ]
datafile<-datafile[!is.na(datafile$Census_IsVirtualDevice), ]
datafile<-datafile[!is.na(datafile$Firewall), ]
datafile<-datafile[!is.na(datafile$Census_PrimaryDiskTotalCapacity), ]
datafile<-datafile[!is.na(datafile$Census_SystemVolumeTotalCapacity), ]
datafile<-datafile[!is.na(datafile$Census_OSInstallLanguageIdentifier), ]
datafile<-datafile[!is.na(datafile$Census_IsAlwaysOnAlwaysConnectedCapable), ]

#tambien se va a eliminar columans con % nulos mayor a 50%

cols.dont.want <- c("DefaultBrowsersIdentifier", "Census_IsFlightingInternal", 
                    "Census_ThresholdOptIn","Census_IsWIMBootEnabled") # if you want to remove multiple columns
datafile <- datafile[, ! names(datafile) %in% cols.dont.want, drop = F]

matriznulos<-matrizdenulos(datafile)

#se encuentra que Census_TotalPhysicalRAM solo tiene 4 nulos se eliminara
datafile<-datafile[!is.na(datafile$Census_TotalPhysicalRAM), ]

matriznulos<-matrizdenulos(datafile)


# DataPreparation-Imputacion de la data----------------------------------------------
#renombrado de variables declaradas por borrado de datos
listclass <- c("ProductName","IsBeta", "RtpStateBitfield", "IsSxsPassiveMode","AVProductsInstalled", 
               "AVProductsEnabled", "HasTpm","Platform", "Processor", "OsPlatformSubRelease",
               "SkuEdition", "IsProtected", "AutoSampleOptIn","PuaMode","SMode", "Firewall", "UacLuaenable", 
               "Census_DeviceFamily","Census_ProcessorClass", "Census_PrimaryDiskTypeName", 
               "Census_HasOpticalDiskDrive","Census_OSArchitecture", "Census_OSInstallTypeName",
               "Census_OSWUAutoUpdateOptionsName","Census_IsPortableOperatingSystem", 
               "Census_GenuineStateName","Census_ActivationChannel", 
               "Census_IsFlightsDisabled","Census_FlightRing", "Census_IsSecureBootEnabled", 
               "Census_IsVirtualDevice", "Census_IsTouchEnabled", 
               "Census_IsPenCapable", "Census_IsAlwaysOnAlwaysConnectedCapable", "Wdft_IsGamer")

listconti <- c("AVProductStatesIdentifier","CountryIdentifier", "CityIdentifier", "OrganizationIdentifier",
               "GeoNameIdentifier", "LocaleEnglishNameIdentifier", "OsBuild", "OsSuite","IeVerIdentifier",
               "Census_OEMNameIdentifier", "Census_OEMModelIdentifier", "Census_ProcessorCoreCount",
               "Census_ProcessorManufacturerIdentifier", "Census_ProcessorModelIdentifier",
               "Census_PrimaryDiskTotalCapacity","Census_SystemVolumeTotalCapacity","Census_TotalPhysicalRAM", 
               "Census_InternalPrimaryDiagonalDisplaySizeInInches", "Census_InternalPrimaryDisplayResolutionHorizontal",
               "Census_InternalPrimaryDisplayResolutionVertical", "Census_InternalBatteryNumberOfCharges",  
               "Census_OSBuildNumber","Census_OSBuildRevision",  "Census_OSInstallLanguageIdentifier", 
               "Census_OSUILocaleIdentifier","Census_FirmwareManufacturerIdentifier", "Census_FirmwareVersionIdentifier",
               "Wdft_RegionIdentifier")
varChar <- c("MachineIdentifier", "EngineVersion", "AppVersion", 
             "AvSigVersion","OsVer","OsBuildLab","SmartScreen", "Census_MDC2FormFactor",  
             "Census_ChassisTypeName",  
             "Census_PowerPlatformRoleName", "Census_InternalBatteryType", 
             "Census_OSVersion", 
             "Census_OSBranch", "Census_OSEdition", "Census_OSSkuName")
vardep<- c("HasDetections")

# DataPreparation - Categorias mal representadas y minoritarias Parte I -----
#validacion de errores en clases
## get mode of all vars
var_mode <- sapply(datafile, mode)
## produce error if complex or raw is found
if (any(var_mode %in% c("complex", "raw"))) stop("complex or raw not allowed!")
## get class of all vars
var_class <- sapply(datafile, class)

## produce error if an "AsIs" object has "logical" or "character" mode
if (any(var_mode[var_class == "AsIs"] %in% c("logical", "character"))) {
  stop("matrix variables with 'AsIs' class must be 'numeric'")
}

## index of factor columns
fctr <- which(sapply(datafile, is.factor))
## factor variables that have skipped explicit conversion in step 2
# drop unused levels
datafile[fctr] <- lapply(datafile[fctr], droplevels)

## export factor levels actually used by `lm` and `glm`
lev <- lapply(datafile[fctr], levels)
## count number of levels
nl <- lengths(lev)

for (vari in listclass)
{cat(vari,sep="\n")
  print(table(datafile[,vari],exclude=NULL))
}

#revisar categorias poco representadas, IsBeta, AutoSampleOptIn, PuaMode, SMode, Census_DeviceFamily,
# Census_IsFlightsDisabled, Census_IsPortableOperatingSystem
#categorias con muchos nulos Census_ProcessorClass,
#eliminar categorias con poca representacion y con muchos nulos
#categoria para arreglar Census_PrimaryDiskTypeName,

cols.dont.want <- c("IsBeta", "AutoSampleOptIn", "PuaMode", "SMode", "Census_DeviceFamily",
                    "Census_IsFlightsDisabled", "Census_IsPortableOperatingSystem", "Census_ProcessorClass") # if you want to remove multiple columns
datafile <- datafile[, ! names(datafile) %in% cols.dont.want, drop = F]

datafile$Census_PrimaryDiskTypeName<-replace(datafile$Census_PrimaryDiskTypeName, 
                                             which(datafile$Census_PrimaryDiskTypeName
                                                   %in% c("", "UNKNOWN", "Unspecified")), NA)

listclass <- c("ProductName", "RtpStateBitfield", "IsSxsPassiveMode","AVProductsInstalled", 
               "AVProductsEnabled", "HasTpm","Platform", "Processor", "OsPlatformSubRelease",
               "SkuEdition", "IsProtected",  "Firewall", "UacLuaenable", 
               "Census_PrimaryDiskTypeName", 
               "Census_HasOpticalDiskDrive","Census_OSArchitecture", "Census_OSInstallTypeName",
               "Census_OSWUAutoUpdateOptionsName", 
               "Census_GenuineStateName","Census_ActivationChannel", 
               "Census_FlightRing", "Census_IsSecureBootEnabled", 
               "Census_IsVirtualDevice", "Census_IsTouchEnabled", 
               "Census_IsPenCapable", "Census_IsAlwaysOnAlwaysConnectedCapable", "Wdft_IsGamer")

## index of factor columns
fctr <- which(sapply(datafile, is.factor))
# drop unused levels
datafile[fctr] <- lapply(datafile[fctr], droplevels)

#validar nuevamente factores, algunos con pocas categorias y mal representadas, podrian dar error
for (vari in listclass)
{cat(vari,sep="\n")
  print(table(datafile[,vari],exclude=NULL))
}

#se revisa que ProductName, UacLuaenable pueden eliminarse
cols.dont.want <- c("ProductName", "UacLuaenable") # if you want to remove multiple columns
datafile <- datafile[, ! names(datafile) %in% cols.dont.want, drop = F]

listclass <- c("RtpStateBitfield", "IsSxsPassiveMode","AVProductsInstalled", 
               "AVProductsEnabled", "HasTpm","Platform", "Processor", "OsPlatformSubRelease",
               "SkuEdition", "IsProtected",  "Firewall", 
               "Census_PrimaryDiskTypeName", 
               "Census_HasOpticalDiskDrive","Census_OSArchitecture", "Census_OSInstallTypeName",
               "Census_OSWUAutoUpdateOptionsName", 
               "Census_GenuineStateName","Census_ActivationChannel", 
               "Census_FlightRing", "Census_IsSecureBootEnabled", 
               "Census_IsVirtualDevice", "Census_IsTouchEnabled", 
               "Census_IsPenCapable", "Census_IsAlwaysOnAlwaysConnectedCapable", "Wdft_IsGamer")


for (vari in listclass)
{cat(vari,sep="\n")
  print(table(datafile[,vari],exclude=NULL))
}

datafile3<-datafile

#se empieza la imputacion con las continuas
#se saca una copia de la variable objetivo
vectvardep <- datafile$HasDetections
input<-datafile[,-69]

indcont <- which(sapply(input, is.integer))
input[indcont] <- sapply(input[, indcont], as.numeric)

input[,as.vector(which(sapply(input, class)=="numeric"))]<-sapply(
  Filter(is.numeric, input),function(x) ImputacionCuant(x,"media"))

matriznulos <- matrizdenulos(input)

# C?digo para imputar varias categ?ricas. Si solo se quiere imputar una, variable<-ImputacionCuali(variable,"moda")

## index of factor columns
fctr <- which(sapply(input, is.factor))
# imputacion cualitativas
input[fctr] <- sapply(
  Filter(is.factor, input),function(x) ImputacionCuali(x,"moda"))
#se cambia el tipo de factor a character al imputar, as? que hay que indicarle que es factor
input[,fctr] <- lapply(input[,fctr], factor)

matriznulos <- matrizdenulos(input)

#datafile<-na.omit(datafile)

# Estandarizacion-----
means <-apply(input[,listconti],2,mean,na.rm=TRUE)
sds<-sapply(input[,listconti],sd,na.rm=TRUE)
datafile2<-scale(input[,listconti], center = means, scale = sds)
input<-data.frame(cbind(datafile2,input[,c(listclass)]))
input <- data.frame(cbind(input, vectvardep))
colnames(input)[colnames(input)=="vectvardep"]<-vardep

matriznulos <- matrizdenulos(input)

datafile<-input

###lo por si acaso
input<-data.frame(cbind(input[,listconti],input[,listclass],vectvardep))
input<-data.frame(cbind(input[,c(listclass)]))
input <- data.frame(cbind(input, vectvardep))
input<-data.frame(cbind(input,))
colnames(input)[colnames(input)=="vectvardep"]<-vardep



# Se va a realizar una primera reduccion de variables en funcion a VCrammer -------
set.seed(1111)
datafile$aleatorio<-runif(nrow(datafile))
salidacramer<-graficoVcramer(datafile[,-c(54)],datafile[,c(54)])
sort(salidacramer, decreasing = T)

# Generacion de dummies ----
#Se valida de nuevo categorias mal representadas para eliminarlas luego de dummies
for (vari in listclass)
{cat(vari,sep="\n")
  print(table(input[,vari],exclude=NULL))
}
#la categorias candidatas son las siguientes:
#RtpStateBitfield.3 , RtpStateBitfield.5, RtpStateBitfield.8
#AVProductsInstalled.4, AVProductsEnabled.0, AVProductsEnabled.0
#Platform.windows7
#Processor.arm64
#OsPlatformSubRelease.windows7
#SkuEdition.Invalid
#Census_OSArchitecture.arm64
#Census_OSInstallTypeName.CleanPCRefresh
#Census_GenuineStateName.UNKNOWN
#Census_FlightRing.Disabled,Census_FlightRing.RP

library(dummies)
datadummies<- dummy.data.frame(datafile, listclass, sep = ".")

datadummies$RtpStateBitfield.3<-NULL
datadummies$RtpStateBitfield.5 <-NULL
datadummies$RtpStateBitfield.8 <- NULL
datadummies$AVProductsInstalled.5 <- NULL
datadummies$AVProductsEnabled.0 <- NULL
datadummies$AVProductsEnabled.4 <- NULL
datadummies$Platform.windows7 <- NULL
datadummies$Processor.arm64 <- NULL
datadummies$OsPlatformSubRelease.windows7 <- NULL
datadummies$SkuEdition.Invalid <- NULL
datadummies$Census_OSArchitecture.arm64 <- NULL
datadummies$Census_OSInstallTypeName.CleanPCRefresh <- NULL
datadummies$Census_GenuineStateName.UNKNOWN <- NULL
datadummies$Census_FlightRing.RP <- NULL

dput(names(datadummies))
datafilebck<-datafile

datafile<- datadummies

# funcion debug--------

debug_contr_error(datafile)


datafile$HasDetections<-ifelse(datafile$HasDetections==1,"Yes","No")
#datadummies2$HasDetections<-ifelse(datadummies2$HasDetections==1,"Yes","No")
#datadummies2$HasDetections <- datadummies$HasDetections

# Regresion Logistica y Redes  -------------------
#seleccion de variables
full<-glm(factor(HasDetections)~.,data=datafile,family = binomial(link="logit")) 
null<-glm(factor(HasDetections)~1,data=datafile,family = binomial(link="logit"))

seleccion<-stepAIC(null,scope=list(upper=full),direction="both")
# Para ver los efectos escogidos dput(names(seleccion$coefficients))
summary(seleccion)
formula(seleccion)

#HasDetections ~ AVProductsInstalled.1 + Census_OSArchitecture.amd64 + 
# Census_IsTouchEnabled.0 + Census_OSWUAutoUpdateOptionsName.Notify + 
#`Census_ActivationChannel.Volume:GVLK` + RtpStateBitfield.0 + 
# Census_IsVirtualDevice.0 + Wdft_IsGamer.0 + AVProductStatesIdentifier + 
# Census_OSInstallTypeName.Update + Census_FlightRing.Retail + 
# Census_OEMNameIdentifier + Census_InternalBatteryNumberOfCharges + 
# Firewall.0 + Census_PrimaryDiskTotalCapacity

# ************************************ # APLICANDO steprepetidobinaria # ************************************ 
lista<-steprepetidobinaria(data=datafile, vardep=vardep,listconti=listconti,sinicio=12345, 
                           sfinal=12355,porcen=0.8,criterio="AIC")
tabla<-lista[[1]]
dput(lista[[2]][[10]])  #es la que tiene mas apariciones
#HasDetections ~ AVProductStatesIdentifier+Census_ProcessorCoreCount+IeVerIdentifier+Census_PrimaryDiskTotalCapacity+
#Census_InternalPrimaryDisplayResolutionVertical+Census_OEMNameIdentifier+Census_FirmwareVersionIdentifier
#c("Census_ProcessorCoreCount", "AVProductStatesIdentifier", "Census_PrimaryDiskTotalCapacity", 
#"IeVerIdentifier", "Census_InternalPrimaryDisplayResolutionVertical", 
#"Census_OEMNameIdentifier", "Census_FirmwareVersionIdentifier"
#)

lista<-steprepetidobinaria(data=datafile, vardep=vardep,listconti=listconti,sinicio=1111, 
                           sfinal=1122,porcen=0.8,criterio="BIC")
tabla<-lista[[1]] 
dput(lista[[2]][[1]]) 
dput(lista[[2]][[2]])
#HasDetections ~AVProductStatesIdentifier+Census_TotalPhysicalRAM
#c("AVProductStatesIdentifier", "Census_TotalPhysicalRAM")

#se va aplicar los modelos de regresion logistica para escoger las variables finales

medias1<-cruzadalogistica(data=datafile, vardep=vardep,
                          listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                                      "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                                      "RtpStateBitfield.0",
                                      "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                                      "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                                      "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                                      "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                                      "Census_PrimaryDiskTotalCapacity"), 
                          listclass=c(""), grupos=4,sinicio=1234,repe=5)
medias1$modelo="Logística1"

medias2<-cruzadalogistica(data=datafile, vardep=vardep,
                          listconti=c("AVProductStatesIdentifier","Census_ProcessorCoreCount","IeVerIdentifier",
                                      "Census_PrimaryDiskTotalCapacity", "Census_InternalPrimaryDisplayResolutionVertical",
                                      "Census_OEMNameIdentifier", "Census_FirmwareVersionIdentifier"), 
                          listclass=c(""), grupos=4,sinicio=1234,repe=5)
medias2$modelo="Logística2"

medias3<-cruzadalogistica(data=datafile, vardep=vardep,
                          listconti=c("AVProductStatesIdentifier", "Census_TotalPhysicalRAM"), 
                          listclass=c(""), grupos=4,sinicio=1234,repe=5)
medias3$modelo="Logística3"

#esto es con valores del arbol, pero no supera al primer modelo
medias3<-cruzadalogistica(data=datafile, vardep=vardep,  #con lo obtenido del arbol
                          listconti=c("AVProductStatesIdentifier","Census_OEMNameIdentifier",
                                      "Census_TotalPhysicalRAM","Census_FirmwareVersionIdentifier",
                                      "Census_OEMModelIdentifier"), 
                          listclass=c(""), grupos=4,sinicio=1234,repe=5)
medias3$modelo="Logística3"



union1<-rbind(medias1,medias2, medias3)
par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS",  cex=8)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)

#Tuneado de la red, con criterio Accuracy (tasa de aciertos)
# Validación cruzada repetida 
control<-trainControl(method = "repeatedcv",number=4,repeats=5, savePredictions = "all",classProbs=TRUE)
# **** avNNet: parámetros
# Number of Hidden Units (size, numeric)
# Weight Decay (decay, numeric) 
# Bagging (bag, logical) 
# ***************************************************** 
avnnetgrid <-expand.grid(size=c(5,10,15,20), decay=c(0.01,0.1,0.001),bag=FALSE)
redavnnet<- train(HasDetections~.,data=datafile, method="avNNet",
                  linout = FALSE,maxit=100, 
                  trControl=control,tuneGrid=avnnetgrid, repeats=5)
redavnnet  #nos quedamos con size 5 y decay 0.1 acc 0.54


redavnnet2 <- train(HasDetections ~ AVProductsInstalled.1 + Census_OSArchitecture.amd64 + 
                    Census_IsTouchEnabled.0 + Census_OSWUAutoUpdateOptionsName.Notify + 
              +     RtpStateBitfield.0 +Census_IsVirtualDevice.0 + Wdft_IsGamer.0 + AVProductStatesIdentifier + 
                    Census_OSInstallTypeName.Update + Census_FlightRing.Retail + 
                    Census_OEMNameIdentifier + Census_InternalBatteryNumberOfCharges + 
                    Firewall.0 + Census_PrimaryDiskTotalCapacity,data=datafile, method="avNNet",
                    linout = FALSE,maxit=100, 
                    trControl=control,tuneGrid=avnnetgrid, repeats=5)

redavnnet2  #en este gana el size 5 y decay 0.1 se obtuvo eun acc=0.58

redavnnet3 <- train(HasDetections ~ AVProductsInstalled.1 + AVProductStatesIdentifier + 
                    RtpStateBitfield.0 + Census_OSArchitecture.amd64+ Census_OSArchitecture.x86+Processor.x64+Processor.x86+
                    Census_ActivationChannel.Retail+Census_OSInstallTypeName.Update+Wdft_IsGamer.0,
                    data=datafile, method="avNNet",
                    linout = FALSE,maxit=100, 
                    trControl=control,tuneGrid=avnnetgrid, repeats=5)

redavnnet3  #en este gana el size 5 y decay 0.1 se obtuvo eun acc=0.58


medias4<-cruzadaavnnetbin(data=datafile,
                          vardep=vardep,listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                                                    "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                                                    "RtpStateBitfield.0",
                                                    "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                                                    "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                                                    "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                                                    "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                                                    "Census_PrimaryDiskTotalCapacity"),
                          listclass=c(""),grupos=4,sinicio=1234,repe=5,
                          size=c(5),decay=c(0.1),repeticiones=5,itera=200) #parametros se colocan de acuerdo a tuneado con auc
medias4$modelo="avnnet"

medias5<-cruzadaavnnetbin(data=datafile,
                          vardep=vardep,listconti=c("AVProductsInstalled.1","AVProductStatesIdentifier", 
                                                    "RtpStateBitfield.0", "Census_OSArchitecture.amd64",
                                                    "Census_OSArchitecture.x86","Processor.x64","Processor.x86",
                                                    "Census_ActivationChannel.Retail", "Census_OSInstallTypeName.Update",
                                                    "Wdft_IsGamer.0"),
                          listclass=c(""),grupos=4,sinicio=1234,repe=5,
                          size=c(5),decay=c(0.1),repeticiones=5,itera=200) #parametros se colocan de acuerdo a tuneado con auc
medias5$modelo="avnnet2"

medias6<-cruzadalogistica(data=datafile, vardep=vardep,
                          listconti=c("AVProductsInstalled.1","AVProductStatesIdentifier", 
                                      "RtpStateBitfield.0", "Census_OSArchitecture.amd64",
                                      "Census_OSArchitecture.x86","Processor.x64","Processor.x86",
                                      "Census_ActivationChannel.Retail", "Census_OSInstallTypeName.Update",
                                      "Wdft_IsGamer.0"), 
                          listclass=c(""), grupos=4,sinicio=1234,repe=5)
medias6$modelo="Logística4"

union1<-rbind(medias1,medias4)
par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=6)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)

# Arboles-----
#tuneado para arbol

arbol <- rpart(HasDetections~.,data = datafilebck,minbucket =10,cp=0,method = "class")
summary(arbol)
par(cex=0.7) 
arbol$variable.importance #Census_OSInstallTypeName,CityIdentifier,AVProductStatesIdentifier,Census_SystemVolumeTotalCapacity,Census_OSBuildRevision,Census_FirmwareVersionIdentifier
plotcp(arbol) #cp 0.0087
rpart.plot(arbol,extra=1,tweak=1.1,nn=TRUE)
par(cex=0.7) 
barplot(arbol$variable.importance,col="orange")

arbol2 <- rpart(HasDetections~., data = datafile,minbucket =30, method = "class",cp=0)
summary(arbol2)
arbol2$variable.importance #AVProductStatesIdentifier, Census_TotalPhysicalRAM,Census_IsTouchEnabled, Census_OEMModelIdentifier,AVProductStatesIdentifier, Census_OEMNameIdentifier,Census_FirmwareVersionIdentifier      
plotcp(arbol2) #cp 0.017
rpart.plot(arbol2,extra=1,tweak=1.1,nn=TRUE)
par(cex=0.7) 
barplot(arbol2$variable.importance,col="orange")


arbol3 <- rpart(HasDetections~., data = datafile,minbucket =40, method = "class",cp=0)
summary(arbol3)
arbol3$variable.importance #AVProductStatesIdentifier, Census_TotalPhysicalRAM, Census_IsTouchEnabled.0,Census_OEMNameIdentifier,Wdft_IsGamer.1, Census_SystemVolumeTotalCapacity
plotcp(arbol3) #cp 0.02
rpart.plot(arbol3,extra=1,tweak=1.1,nn=TRUE)
par(cex=0.7) 
barplot(arbol3$variable.importance,col="orange")


# CON ARBOL: con rpart SE PUEDE TUNEAR EL CP
arbolgrid <- expand.grid(cp=c(0,0.001,0.05,0.017,0.1))
arbolcaret<- train(factor(HasDetections)~AVProductStatesIdentifier+Census_TotalPhysicalRAM+Census_IsTouchEnabled.0+ 
                   Census_OEMModelIdentifier+AVProductStatesIdentifier+ Census_OEMNameIdentifier+
                   Census_FirmwareVersionIdentifier,
                   data=datafile, method="rpart",minbucket=30,trControl=control,tuneGrid=arbolgrid)
arbolcaret
sal<-arbolcaret$pred
salconfu<-confusionMatrix(sal$pred,sal$obs)
salconfu
curvaroc<-roc(response=sal$obs,predictor=sal$Yes) 
auc<-curvaroc$auc 
auc 
plot(roc(response=sal$obs,predictor=sal$Yes))

arbolgrid <- expand.grid(cp=c(0,0.001,0.02,0.05,0.1))
arbolcaret2<- train(factor(HasDetections)~AVProductStatesIdentifier+Census_TotalPhysicalRAM+
                      Census_IsTouchEnabled.0+Census_OEMNameIdentifier+Wdft_IsGamer.1+Census_SystemVolumeTotalCapacity,
                   data=datafile, method="rpart",minbucket=40,trControl=control,tuneGrid=arbolgrid)
arbolcaret2
sal<-arbolcaret2$pred
salconfu<-confusionMatrix(sal$pred,sal$obs)
salconfu
curvaroc<-roc(response=sal$obs,predictor=sal$Yes) 
auc<-curvaroc$auc 
auc 
plot(roc(response=sal$obs,predictor=sal$Yes))


medias7<-cruzadaarbolbin(data=datafile,
        vardep=vardep,
        listconti=c("AVProductStatesIdentifier","Census_TotalPhysicalRAM",
                      "Census_IsTouchEnabled.0","Census_OEMNameIdentifier","Wdft_IsGamer.1",
                    "Census_SystemVolumeTotalCapacity"),
        listclass=c(""),grupos=4,sinicio=1234,repe=5, cp=c(0.02),minbucket =40)
 
medias7$modelo="arbol"

union1<-rbind(medias1,medias4, medias7)
#par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=6)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)

# Bagging ------

set.seed(12345)

for (muestra in seq(100,450,50)) { # controlamos la semilla pues bagging depende de ella set.seed(12345) 
  rfbis<-randomForest(factor(HasDetections)~AVProductsInstalled.1+Census_OSArchitecture.amd64+Census_IsTouchEnabled.0+
                      Census_OSWUAutoUpdateOptionsName.Notify+RtpStateBitfield.0+ Census_IsVirtualDevice.0+
                      Wdft_IsGamer.0+AVProductStatesIdentifier+Census_OSInstallTypeName.Update+
                      Census_FlightRing.Retail+Census_OEMNameIdentifier+Census_InternalBatteryNumberOfCharges+
                      Firewall.0+ Census_PrimaryDiskTotalCapacity, data=datafile,
                      mtry=14,ntree=5000,sampsize=muestra,nodesize=10,replace=TRUE)
  
  plot(rfbis$err.rate[,1],main=muestra)
  print(rfbis)
}

rfgrid<-expand.grid(mtry=14) #Para bagging en mtry se pone el número total de var inddependientes del modelo 
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
rf<- train(factor(HasDetections)~AVProductsInstalled.1+Census_OSArchitecture.amd64+Census_IsTouchEnabled.0+
             Census_OSWUAutoUpdateOptionsName.Notify+RtpStateBitfield.0+ Census_IsVirtualDevice.0+
             Wdft_IsGamer.0+AVProductStatesIdentifier+Census_OSInstallTypeName.Update+
             Census_FlightRing.Retail+Census_OEMNameIdentifier+Census_InternalBatteryNumberOfCharges+
             Firewall.0+ Census_PrimaryDiskTotalCapacity
              ,data=datafile, method="rf",
              trControl=control,tuneGrid=rfgrid, linout = FALSE,ntree=200,
              sampsize=250,nodesize=10,replace=TRUE) 
rf

medias8<-cruzadarfbin(data=datafile, vardep=vardep,
                      listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                        "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                        "RtpStateBitfield.0",
                        "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                        "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                        "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                        "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                        "Census_PrimaryDiskTotalCapacity"), 
                      listclass=c(""),
                      grupos=4,sinicio=1234,repe=5,nodesize=10,
                      mtry=14,ntree=200,replace=TRUE)
# 
medias8$modelo="bagging"

union1<-rbind(medias1,medias4, medias7, medias8)
#par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=6)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)

# Random Forest-----

#para random forest se tone el mtry
# TUNEADO DE MTRY CON CARET
set.seed(12345)
rfgrid<-expand.grid(mtry=c(3,4,5,6,7,8,9,10,11)) 
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
rf<- train(HasDetections~.,data=datafile, method="rf",trControl=control,
           tuneGrid=rfgrid, linout = FALSE,ntree=1000,sampsize=250,nodesize=10,
           replace=TRUE, importance=TRUE)
rf  #mtry = 3  es el escogido

#importancia de las variables
final<-rf$finalModel
tabla<-as.data.frame(importance(final)) 
tabla<-tabla[order(-tabla$MeanDecreaseAccuracy),] 
tabla #AVProductStatesIdentifier,AVProductsInstalled.1,RtpStateBitfield.7,AVProductsInstalled.2,RtpStateBitfield.0.,Census_OSArchitecture.x86, 

barplot(tabla$MeanDecreaseAccuracy,names.arg=rownames(tabla))

#TUNEADO BÁSICO DEL TAMAÑO DE MUESTRA A SORTEAR 
# NOTA: ESTE TRUCO SE PUEDE USAR EN CUALQUIER FUNCIÓN, ÚTIL
# PARA TUNEAR PARÁMETROS QUE CARET NO PERMITE EN EL GRID
for (muestra in seq(100,450,50)) { # controlamos la semilla pues bagging depende de ella, pendiente de correr 
  set.seed(12345) 
  rfbis<-randomForest(factor(HasDetections)~AVProductStatesIdentifier+AVProductsInstalled.1+
                        RtpStateBitfield.7+AVProductsInstalled.2+RtpStateBitfield.0+Census_OSArchitecture.x86, 
                      data=datafile, mtry=3,
                      ntree=5000,sampsize=muestra,nodesize=10,replace=TRUE)
  plot(rfbis$err.rate[,1],main=muestra,ylim=c(0.25,0.5))
  print(muestra)
  print(rfbis)
  
}
# Ahora se comprueba con validación cruzada con caret
rfgrid<-expand.grid(mtry=c(3))
rf<- train(factor(HasDetections)~AVProductStatesIdentifier+AVProductsInstalled.1+
             RtpStateBitfield.7+AVProductsInstalled.2+RtpStateBitfield.0+Census_OSArchitecture.x86,
           data=datafile, method="rf",
           trControl=control,tuneGrid=rfgrid, linout = FALSE,
           ntree=1000,sampsize=300,nodesize=10,replace=TRUE)
rf

#ahora si se calcula con el mtry tuneado
medias9<-cruzadarfbin(data=datafile, vardep=vardep, 
                      listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                                  "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                                  "RtpStateBitfield.0",
                                  "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                                  "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                                  "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                                  "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                                  "Census_PrimaryDiskTotalCapacity"), 
                      listclass=c(""), grupos=4,sinicio=1234,repe=10,nodesize=10, 
                      mtry=3,ntree=100,replace=TRUE,sampsize = 300)
medias9$modelo="rf1" #acc 0.5847579

medias10<-cruzadarfbin(data=datafile, vardep=vardep, 
                      listconti=c("AVProductStatesIdentifier","AVProductsInstalled.1",
                                    "RtpStateBitfield.7","AVProductsInstalled.2","RtpStateBitfield.0",
                                  "Census_OSArchitecture.x86"), 
                      listclass=c(""), grupos=4,sinicio=1234,repe=10,nodesize=10, 
                      mtry=3,ntree=100,replace=TRUE, sampsize = 300)
medias10$modelo="rf2" #acc 0.5876017


union1<-rbind(medias1,medias4, medias7, medias10)
#par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=6)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)

# Gradient Boosting ----
#tuneo de parametros shrinkage y n.trees

gbmgrid<-expand.grid(shrinkage=c(0.1,0.05,0.03,0.01,0.001),
                     n.minobsinnode=c(5,10,20), n.trees=c(100,500,1000,5000), interaction.depth=c(2))
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
gbm<- train(factor(HasDetections)~.,data=datafile, method="gbm",
            trControl=control,tuneGrid=gbmgrid, distribution="bernoulli", 
            bag.fraction=1,verbose=FALSE)
gbm   #shrinkage 0.03 y n.trees 1000, n.minobsinnode = 5
plot(gbm)


# ESTUDIO DE EARLY STOPPING
# Probamos a fijar algunos parámetros para ver como evoluciona # en función de las iteraciones
gbmgrid<-expand.grid(shrinkage=c(0.03), n.minobsinnode=c(5),
                     n.trees=c(50,100,500,1000,5000), interaction.depth=c(2))
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
gbm<- train(factor(HasDetections)~.,data=datafile, method="gbm",trControl=control,
            tuneGrid=gbmgrid, distribution="bernoulli", bag.fraction=1,verbose=FALSE)
gbm
plot(gbm,ylim=c(0.50,0.6))

# IMPORTANCIA DE VARIABLES
summary(gbm)
tabla<-summary(gbm)
par(cex=1.5,las=2)
barplot(tabla$rel.inf,names.arg=row.names(tabla)) #AVProductStatesIdentifier,Census_SystemVolumeTotalCapacity,AVProductsInstalled.1,Census_TotalPhysicalRAM,Census_FirmwareVersionIdentifier,CityIdentifier,Census_ActivationChannel.Retail,Census_FirmwareManufacturerIdentifier      


#se prueba con las variables de gbm

gbmgrid<-expand.grid(shrinkage=c(0.03), n.minobsinnode=c(5),
                     n.trees=c(50,100,500,1000,5000), interaction.depth=c(2))
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
gbm<- train(factor(HasDetections)~AVProductStatesIdentifier+
              Census_SystemVolumeTotalCapacity+AVProductsInstalled.1+
              Census_TotalPhysicalRAM+Census_FirmwareVersionIdentifier+
              CityIdentifier+Census_ActivationChannel.Retail+Census_FirmwareManufacturerIdentifier,
              data=datafile, method="gbm",trControl=control,
            tuneGrid=gbmgrid, distribution="bernoulli", bag.fraction=1,verbose=FALSE)
gbm

#se prueba con las variables de stepwise
gbmgrid<-expand.grid(shrinkage=c(0.03), n.minobsinnode=c(5),
                     n.trees=c(50,100,500,1000,5000), interaction.depth=c(2))

control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
gbm2<- train(factor(HasDetections)~AVProductsInstalled.1+Census_OSArchitecture.amd64+
            Census_IsTouchEnabled.0+Census_OSWUAutoUpdateOptionsName.Notify+RtpStateBitfield.0+
            Census_IsVirtualDevice.0+Wdft_IsGamer.0+AVProductStatesIdentifier+Census_OSInstallTypeName.Update+
            Census_FlightRing.Retail+Census_OEMNameIdentifier+Census_InternalBatteryNumberOfCharges+
            Firewall.0+Census_PrimaryDiskTotalCapacity,
            data=datafile, method="gbm",trControl=control,
            tuneGrid=gbmgrid, distribution="bernoulli", bag.fraction=1,verbose=FALSE)
gbm2

medias11<-cruzadagbmbin(data=datafile, vardep=vardep, 
                       listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                                   "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                                   "RtpStateBitfield.0",
                                   "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                                   "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                                   "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                                   "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                                   "Census_PrimaryDiskTotalCapacity"), 
                       listclass=c(""), grupos=4,sinicio=1234,repe=5, n.minobsinnode=5,
                       shrinkage=0.03,n.trees=1000,interaction.depth=2)
medias11$modelo="gbm"

union1<-rbind(medias1,medias4, medias7, medias10, medias11)
#par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=6)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)


# XGBM -----------------

# TUNEADO DE XGBOOST CON CARET
# Caret permite tunear estos parámetros básicos: 
# 
# nrounds (# Boosting Iterations) 
# max_depth (Max Tree Depth) 
# eta (Shrinkage) 
# gamma (Minimum Loss Reduction) 
# colsample_bytree (Subsample Ratio of Columns)
# min_child_weight (Minimum Sum of Instance Weight)
# subsample (Subsample Percentage)
set.seed(12345)
xgbmgrid<-expand.grid( min_child_weight=c(5,10,20), eta=c(0.1,0.05,0.03),
                       nrounds=c(100,500,1000,5000), max_depth=5,gamma=0,colsample_bytree=1,subsample=1)
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
xgbm<- train(factor(HasDetections)~.,data=datafile, method="xgbTree",trControl=control,
             tuneGrid=xgbmgrid,verbose=FALSE)
xgbm  #max_depth = 5, gamma = 0, colsample_bytree = 1, subsample = 1,
#nrounds = 100, max_depth = 5, eta = 0.03, gamma = 0, colsample_bytree =1, min_child_weight = 10 and subsample = 1
plot(xgbm)

# ESTUDIO DE EARLY STOPPING
# Probamos a fijar algunos parámetros para ver como evoluciona
# en función de las iteraciones
xgbmgrid<-expand.grid(eta=c(0.03), min_child_weight=c(5), 
                      nrounds=c(50,100,150,200,250,300), 
                      max_depth=6,gamma=0,colsample_bytree=1,subsample=1)
set.seed(12345)
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
xgbm<- train(factor(HasDetections)~.,data=datafile, method="xgbTree",trControl=control, tuneGrid=xgbmgrid,verbose=FALSE)
plot(xgbm,ylim=c(0.65,0.76))

# IMPORTANCIA DE VARIABLES
varImp(xgbm)
plot(varImp(xgbm))

# PRUEBO PARÁMETROS CON VARIABLES SELECCIONADAS
xgbmgrid<-expand.grid( min_child_weight=c(5,10,20), 
                       eta=c(0.1,0.05,0.03,0.01,0.001), 
                       nrounds=c(100,500,1000,5000),
                       max_depth=6,gamma=0,colsample_bytree=1,subsample=1)
control<-trainControl(method = "cv",number=4,savePredictions = "all", classProbs=TRUE)
xgbm<- train(factor(HasDetections)~tobacco+ldl+adiposity+age+typea+famhist.Absent, data=saheartbis,
             method="xgbTree",trControl=control, tuneGrid=xgbmgrid,verbose=FALSE)
xgbm
plot(xgbm)

# recorto el archivo
datafilexbm<-datafile[,c("tobacco", "ldl","age", "typea", "famhist.Absent","chd")]
# UTILIZACIÓN DE LOS PARÁMETROS DE REGULARIZACIÓN
# SE CREAN DATA FRAMES VACÍOS Y SE VA METIENDO EL RESULTADO
# DE REALIZAR EL PROCESO CON CADA VALOR DEL PARÁMETRO DE # REGULARIZACIÓN
xgbmgrid<-expand.grid(eta=c(0.001), min_child_weight=c(5), nrounds=c(500), 
                      max_depth=6,gamma=0,colsample_bytree=1,subsample=1)
df<- data.frame(matrix(ncol = 2, nrow = 0)) 
x <- c("lambda", "Accuracy") 
colnames(df) <- x 
df2<- data.frame(matrix(ncol = 2, nrow = 0)) 
x <- c("lambda", "Accuracy") 
colnames(df2) <- x
for (lambda in seq(0,20,1)) 
{ 
  xgbm<- train(factor(chd)~.,data=saheartbis, method="xgbTree",trControl=control, 
               tuneGrid=xgbmgrid,lambda=lambda,verbose=FALSE) 
  cat(lambda,"\n") 
  cat(xgbm$results$Accuracy,"\n") 
  df[1,1]<-lambda 
  df[1,2]<-xgbm$results$Accuracy 
  df2<-rbind(df2,df) 
}
plot(df2$lambda,df2$Accuracy)
xgbm$results$Accuracy

#nrounds = 100, max_depth = 5, eta = 0.03, gamma = 0, colsample_bytree =1, min_child_weight = 10 and subsample = 1
medias12<-cruzadaxgbmbin(data=datafile, vardep=vardep,
                         listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                                     "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                                     "RtpStateBitfield.0",
                                     "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                                     "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                                     "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                                     "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                                     "Census_PrimaryDiskTotalCapacity"), 
                        listclass=c(""), grupos=4,sinicio=1234,repe=5, 
                        min_child_weight=10,eta=0.03,nrounds=5000,
                        max_depth=6, gamma=0,colsample_bytree=1,subsample=1, 
                        alpha=0,lambda=0,lambda_bias=0)
medias12$modelo="xgbm"

union1<-rbind(medias1,medias4, medias7, medias10, medias11,medias12)
#par(cex.axis=0.5) 
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=6)
boxplot(data=union1,auc~modelo,main="AUC", cex=1)

# SVM -------------------

#tuneado con caret

SVMgrid<-expand.grid(C=c(0.01,0.05,0.1,0.2,0.5,1,2,5,10))
control<-trainControl(method = "cv",number=4,savePredictions = "all")
SVM<- train(data=datafile,factor(HasDetections)~., 
            method="svmLinear",trControl=control, tuneGrid=SVMgrid,verbose=FALSE) 
SVM  #c=0.01
SVM$results 
plot(SVM$results$C,SVM$results$Accuracy)


SVMgrid<-expand.grid(C=c(0.01,0.05,0.1,0.2,0.5,1,2,5,10),
                     degree=c(2,3),scale=c(0.1,0.5,1,2,5))
control<-trainControl(method = "cv", number=4,savePredictions = "all")
SVM<- train(data=datafile,factor(HasDetections)~.,
            method="svmPoly",trControl=control, tuneGrid=SVMgrid,verbose=FALSE)
SVM # degree = 2, scale = 0.1 and C = 0.01

SVM$results
dat<-as.data.frame(SVM$results)

# PLOT DE DOS VARIABLES CATEGÓRICAS, UNA CONTINUA 
ggplot(dat, aes(x=factor(C), y=Accuracy, color=factor(degree),pch=factor(scale))) + geom_point(position=position_dodge(width=0.5),size=3)


SVMgrid<-expand.grid(C=c(0.01,0.05,0.1,0.2,0.5,1,2,5,10,30), 
                     sigma=c(0.01,0.05,0.1,0.2,0.5,1,2,5,10,30))
control<-trainControl(method = "cv", number=4,savePredictions = "all")
SVM<- train(data=datafile,factor(HasDetections)~., 
            method="svmRadial",trControl=control, tuneGrid=SVMgrid,verbose=FALSE)
SVM #sigma = 0.01 and C = 2

dat<-as.data.frame(SVM$results)
ggplot(dat, aes(x=factor(C), y=Accuracy, color=factor(sigma))) + geom_point(position=position_dodge(width=0.5),size=3)


medias13<-cruzadaSVMbin(data=datafile, vardep=vardep,
 listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
             "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
             "RtpStateBitfield.0",
             "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
             "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
             "Census_FlightRing.Retail","Census_OEMNameIdentifier",
             "Census_InternalBatteryNumberOfCharges", "Firewall.0",
             "Census_PrimaryDiskTotalCapacity"),
   listclass=c(""),
   grupos=4,sinicio=1234,repe=5,
   C=0.01)
 
 medias13$modelo="SVM"
# 
# # degree = 2, scale = 0.1 and C = 0.01
medias14<-cruzadaSVMbinPoly(data=datafile, vardep=vardep,
    listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                "RtpStateBitfield.0",
                "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                "Census_PrimaryDiskTotalCapacity"),
  listclass=c(""),
   grupos=4,sinicio=1234,repe=5,
   C=0.01,degree=2,scale=0.1)
 
 medias14$modelo="SVMPoly"

 source("cruzadaSVMbinRBF.R")
 #para radial sigma = 0.01 and C = 2
 medias15<-cruzadaSVMbinRBF(data=datafile, vardep=vardep, 
                            listconti=c("AVProductsInstalled.1", "Census_OSArchitecture.amd64",
                                        "Census_IsTouchEnabled.0","Census_OSWUAutoUpdateOptionsName.Notify",
                                        "RtpStateBitfield.0",
                                        "Census_IsVirtualDevice.0", "Wdft_IsGamer.0",
                                        "AVProductStatesIdentifier", "Census_OSInstallTypeName.Update",
                                        "Census_FlightRing.Retail","Census_OEMNameIdentifier",
                                        "Census_InternalBatteryNumberOfCharges", "Firewall.0",
                                        "Census_PrimaryDiskTotalCapacity"), 
                            listclass=c(""), grupos=4,sinicio=1234,repe=5, C=2,sigma=0.01)
 medias15$modelo="SVMRBF"
 
 
 union1<-rbind(medias1,medias4, medias7, medias10, medias11,medias13,medias14,medias15)
 #par(cex.axis=0.5) 
 boxplot(data=union1,tasa~modelo,main="TASA FALLOS", cex=1)
 boxplot(data=union1,auc~modelo,main="AUC", cex=1)
 
 saveRDS(data.frame(datafile),"datafilecleanmalware")
 
 
 # ensamblado -------------
 source("cruzadasensambladobin.R")
 set.seed(12345)
 
 
 medias1bis<-as.data.frame(medias1[1])
 medias1bis$modelo<-"Logistica"
 predi1<-as.data.frame(medias1[2])
 predi1$logi<-predi1$Yes
 
 medias4bis<-as.data.frame(medias4[1])
 medias4bis$modelo<-medias4
 predi4<-as.data.frame(medias4[2])
 predi4$rf<-predi4$Yes
 
 medias7bis<-as.data.frame(medias7[1])
 medias7bis$modelo<-medias7
 predi7<-as.data.frame(medias7[2])
 predi7$rf<-predi7$Yes
 
 medias10bis<-as.data.frame(medias10[1])
 medias10bis$modelo<-medias10
 predi10<-as.data.frame(medias10[2])
 predi10$rf<-predi10$Yes
 
 medias11bis<-as.data.frame(medias11[1])
 medias11bis$modelo<-medias11
 predi11<-as.data.frame(medias11[2])
 predi11$rf<-predi11$Yes
 
 medias13bis<-as.data.frame(medias13[1])
 medias13bis$modelo<-medias13
 predi13<-as.data.frame(medias13[2])
 predi13$rf<-predi13$Yes
 
 medias14bis<-as.data.frame(medias14[1])
 medias14bis$modelo<-medias14
 predi14<-as.data.frame(medias14[2])
 predi14$rf<-predi14$Yes
 
 medias15bis<-as.data.frame(medias15[1])
 medias15bis$modelo<-medias15
 predi15<-as.data.frame(medias15[2])
 predi15$rf<-predi15$Yes
 
 
 # CONSTRUCCIÓN DE TODOS LOS ENSAMBLADOS
 # SE UTILIZARÁN LOS ARCHIVOS SURGIDOS DE LAS FUNCIONES LLAMADOS predi1,...
 
 unipredi<-cbind(predi1,predi4,predi7,predi10,predi11,predi13,predi14,predi15)
 
 # Esto es para eliminar columnas duplicadas
 unipredi<- unipredi[, !duplicated(colnames(unipredi))]
 
 # Construccion de ensamblados, cambiar al gusto
 
 unipredi$predi9<-(unipredi$logi+unipredi$avnnet)/2
 unipredi$predi10<-(unipredi$logi+unipredi$rf)/2
 unipredi$predi11<-(unipredi$logi+unipredi$gbm)/2
 unipredi$predi12<-(unipredi$logi+unipredi$xgbm)/2
 unipredi$predi13<-(unipredi$logi+unipredi$svmLinear)/2
 unipredi$predi14<-(unipredi$logi+unipredi$svmPoly)/2
 unipredi$predi15<-(unipredi$logi+unipredi$svmRadial)/2
 unipredi$predi16<-(unipredi$avnnet+unipredi$rf)/2
 unipredi$predi17<-(unipredi$avnnet+unipredi$gbm)/2
 unipredi$predi18<-(unipredi$avnnet+unipredi$xgbm)/2
 unipredi$predi19<-(unipredi$avnnet+unipredi$svmLinear)/2
 unipredi$predi20<-(unipredi$avnnet+unipredi$svmPoly)/2
 unipredi$predi21<-(unipredi$avnnet+unipredi$svmRadial)/2
 unipredi$predi22<-(unipredi$rf+unipredi$gbm)/2
 unipredi$predi23<-(unipredi$rf+unipredi$xgbm)/2
 unipredi$predi24<-(unipredi$rf+unipredi$svmLinear)/2
 unipredi$predi25<-(unipredi$rf+unipredi$svmPoly)/2
 unipredi$predi26<-(unipredi$rf+unipredi$svmRadial)/2
 unipredi$predi27<-(unipredi$gbm+unipredi$xgbm)/2
 unipredi$predi28<-(unipredi$gbm+unipredi$svmLinear)/2
 unipredi$predi29<-(unipredi$gbm+unipredi$svmPoly)/2
 unipredi$predi30<-(unipredi$gbm+unipredi$svmRadial)/2
 
 unipredi$predi31<-(unipredi$logi+unipredi$avnnet+unipredi$rf)/3
 unipredi$predi32<-(unipredi$logi+unipredi$avnnet+unipredi$gbm)/3
 unipredi$predi33<-(unipredi$logi+unipredi$avnnet+unipredi$xgbm)/3
 unipredi$predi34<-(unipredi$logi+unipredi$avnnet+unipredi$svmLinear)/3
 unipredi$predi35<-(unipredi$logi+unipredi$avnnet+unipredi$svmPoly)/3
 unipredi$predi36<-(unipredi$logi+unipredi$avnnet+unipredi$svmRadial)/3
 unipredi$predi37<-(unipredi$logi+unipredi$rf+unipredi$gbm)/3
 unipredi$predi38<-(unipredi$logi+unipredi$rf+unipredi$xgbm)/3
 unipredi$predi39<-(unipredi$logi+unipredi$rf+unipredi$svmLinear)/3
 unipredi$predi40<-(unipredi$logi+unipredi$rf+unipredi$svmPoly)/3
 unipredi$predi41<-(unipredi$logi+unipredi$rf+unipredi$svmRadial)/3
 unipredi$predi42<-(unipredi$logi+unipredi$gbm+unipredi$xgbm)/3
 unipredi$predi43<-(unipredi$logi+unipredi$gbm+unipredi$xgbm)/3
 unipredi$predi44<-(unipredi$logi+unipredi$gbm+unipredi$svmLinear)/3
 unipredi$predi45<-(unipredi$logi+unipredi$gbm+unipredi$svmPoly)/3
 unipredi$predi46<-(unipredi$logi+unipredi$gbm+unipredi$svmRadial)/3
 unipredi$predi47<-(unipredi$logi+unipredi$xgbm+unipredi$svmLinear)/3
 unipredi$predi48<-(unipredi$logi+unipredi$xgbm+unipredi$svmPoly)/3
 unipredi$predi49<-(unipredi$logi+unipredi$xgbm+unipredi$svmRadial)/3
 
 unipredi$predi50<-(unipredi$rf+unipredi$gbm+unipredi$svmLinear)/3
 unipredi$predi51<-(unipredi$rf+unipredi$gbm+unipredi$svmPoly)/3
 unipredi$predi52<-(unipredi$rf+unipredi$gbm+unipredi$svmRadial)/3
 
 unipredi$predi53<-(unipredi$rf+unipredi$xgbm+unipredi$svmLinear)/3
 unipredi$predi54<-(unipredi$rf+unipredi$xgbm+unipredi$svmPoly)/3
 unipredi$predi55<-(unipredi$rf+unipredi$xgbm+unipredi$svmRadial)/3
 
 unipredi$predi56<-(unipredi$rf+unipredi$avnnet+unipredi$gbm)/3
 unipredi$predi57<-(unipredi$rf+unipredi$avnnet+unipredi$xgbm)/3
 unipredi$predi58<-(unipredi$rf+unipredi$avnnet+unipredi$svmLinear)/3
 unipredi$predi59<-(unipredi$rf+unipredi$avnnet+unipredi$svmPoly)/3
 unipredi$predi60<-(unipredi$rf+unipredi$avnnet+unipredi$svmRadial)/3
 
 unipredi$predi61<-(unipredi$avnnet+unipredi$gbm+unipredi$svmLinear)/3
 unipredi$predi62<-(unipredi$avnnet+unipredi$gbm+unipredi$svmPoly)/3
 unipredi$predi63<-(unipredi$avnnet+unipredi$gbm+unipredi$svmRadial)/3
 
 unipredi$predi64<-(unipredi$logi+unipredi$rf+unipredi$gbm+unipredi$avnnet)/4
 unipredi$predi65<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet)/4
 unipredi$predi66<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet)/4
 
 unipredi$predi67<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmLinear)/5
 unipredi$predi68<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmPoly)/5
 unipredi$predi69<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmRadial)/5
 
 
 # Listado de modelos a considerar, cambiar al gusto
 
 dput(names(unipredi))
 
 listado<-c("logi", "avnnet", 
            "rf","gbm",  "xgbm", "svmLinear",  "svmPoly", 
            "svmRadial","predi9", "predi10", "predi11", "predi12", 
            "predi13", "predi14", "predi15", "predi16", "predi17", "predi18", 
            "predi19", "predi20", "predi21", "predi22", "predi23", "predi24", 
            "predi25", "predi26", "predi27", "predi28", "predi29", "predi30", 
            "predi31", "predi32", "predi33", "predi34", "predi35", "predi36", 
            "predi37", "predi38", "predi39", "predi40", "predi41", "predi42", 
            "predi43", "predi44", "predi45", "predi46", "predi47", "predi48", 
            "predi49", "predi50", "predi51", "predi52", "predi53", "predi54", 
            "predi55", "predi56", "predi57", "predi58", "predi59", "predi60", 
            "predi61", "predi62", "predi63", "predi64", "predi65", "predi66", 
            "predi67", "predi68", "predi69")
 
 # Cambio a Yes, No, todas las predicciones
 
 # Defino funcion tasafallos
 
 tasafallos<-function(x,y) {
   confu<-confusionMatrix(x,y)
   tasa<-confu[[3]][1]
   return(tasa)
 }
 
 auc<-function(x,y) {
   curvaroc<-roc(response=x,predictor=y)
   auc<-curvaroc$auc
   return(auc)
 }
 
 # Se obtiene el numero de repeticiones CV y se calculan las medias por repe en
 # el data frame medias0
 
 repeticiones<-nlevels(factor(unipredi$Rep))
 unipredi$Rep<-as.factor(unipredi$Rep)
 unipredi$Rep<-as.numeric(unipredi$Rep)
 
 
 medias0<-data.frame(c())
 for (prediccion in listado)
 {
   unipredi$proba<-unipredi[,prediccion]
   unipredi[,prediccion]<-ifelse(unipredi[,prediccion]>0.5,"Yes","No")
   for (repe in 1:repeticiones)
   {
     paso <- unipredi[(unipredi$Rep==repe),]
     pre<-factor(paso[,prediccion])
     archi<-paso[,c("proba","obs")]
     archi<-archi[order(archi$proba),]
     obs<-paso[,c("obs")]
     tasa=1-tasafallos(pre,obs)
     t<-as.data.frame(tasa)
     t$modelo<-prediccion
     auc<-auc(archi$obs,archi$proba)
     t$auc<-auc
     medias0<-rbind(medias0,t)
   }
 }
 
 
 # Finalmente boxplot
 
 par(cex.axis=0.5,las=2)
 boxplot(data=medias0,tasa~modelo)
 
 # Para AUC se utiliza la variable auc del archivo medias0
 
 boxplot(data=medias0,auc~modelo)
 
 
 # PRESENTACION TABLA MEDIAS
 
 tablamedias<-medias0 %>%
   group_by(modelo) %>%
   summarize(tasa=mean(tasa))     
 
 tablamedias<-tablamedias[order(tablamedias$tasa),]
 
 
 # ORDENACIÓN DEL FACTOR MODELO POR LAS MEDIAS EN TASA
 # PARA EL GRAFICO
 
 medias0$modelo <- with(medias0,
                        reorder(modelo,tasa, mean))
 par(cex.axis=0.7,las=2)
 boxplot(data=medias0,tasa~modelo,col="pink")
 
 # ************************************
 # PARA AUC
 # ************************************
 
 # PRESENTACION TABLA MEDIAS
 
 tablamedias2<-medias0 %>%
   group_by(modelo) %>%
   summarize(auc=mean(auc))     
 
 tablamedias2<-tablamedias2[order(-tablamedias2$auc),]
 
 
 # ORDENACIÓN DEL FACTOR MODELO POR LAS MEDIAS EN AUC
 # PARA EL GRAFICO
 
 medias0$modelo <- with(medias0,
                        reorder(modelo,auc, mean))
 par(cex.axis=0.7,las=2)
 boxplot(data=medias0,auc~modelo,col="pink")
 
 
 
 